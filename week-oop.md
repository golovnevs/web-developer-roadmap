<h1>Парадигмы программирования</h1>

Неделя ООП. День 1.  Философия ООП.

Иногда, возможно, буду выкладывать сюда краткие конcпекты уроков из курса "Неделя ООП" Дмитрия Елисеева. 

Итак, какие бывают парадигмы программирования.

Императивное программирование

Последовательность конкретных инструкций для достижения определенной цели. Отвечает на вопрос "Как?".

Императивный стиль:

Открой фотошоп
Создай документ
Залей фон
Открой фотошоп
Создай документ
Залей фон
Открой фотошоп
Создай документ
Залей фон

Пример императивного языка: Assemnbler

Декларативное программирование

Последовательность готовых функций, приводящих к поставленной цели. Отвечает на вопрос "Что?".

Сделай дизайн по примерно такому макету -> ... -> Дизайн

Приемер декларативных языков: SQL, HTML

Более подробно про декларативный стиль — habrahabr.ru/post/324688/

Структурное программирование

Представление программы в виде иерархической структуры блоков.

Принципы:

- Следует отказаться от использования оператора безусловного перехода goto.

- Любая программа строится из трёх базовых управляющих конструкций: последовательность, ветвление, цикл.

- В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом.

- Каждую логически законченную группу инструкций следует оформить как блок (block).

- Все перечисленные конструкции должны иметь один вход и один выход.

- Разработка программы ведётся пошагово, методом «сверху вниз

procedure init() {...}

function process(a) {if (...) {...} else {...} return ...;}

init();
a := process(b);
export(a);

Процедурное программирование 

Разнесение кода по процедурам и функциям с использованием циклов и условий.

students = loadStudentsFromFile(file);

filtereds = [];
result = '';

foreach (students as student) {...}
foreach (filtereds as filtered) { result = ...;}

print result;

Функциональное программирование

Использование готовых или собственных фукнций.

print reduce(join, map(getFullName,filter(isOchn, loadStudentsFromFile(file))));

Оъектно-ориентированное программирование

Использование собственных структур данных (объектов)

class Student 
{
  var $firstName;
  var $lastName;
  var $birthDate;

  function getFullName() { ... }
}

$student = new Student();

$student->firstName = 'Vasya';
$student->lastName = 'Pupkin';

echo $student->getFullName();

Отход от процедурного программирования к ООП

- Сначала был лапшекод
- Процедуры облегчили лапшекод
- Возникло неудобство сотен процедур
- Появилась разрозненность данных
- Компоновка по смыслу привела к ООП

Кому и как объекты упрощают жизнь, а кому усложняют

Хорошее ООП
- Разгружает голову
- Привносит модульность
- Повышает совместимость
- Локализует изменения
- Абстрагируется от реализации
- Упрощает код
- Легко тестируется

Недо-ООП
- Привносит сложность
- Сохраняет процедурный подход
- Причиняет неудобство
- Т.е. никакой пользы не привносит

Хорошее ООП позволяет писать максимально независимые, настраиваемые,  расширяемые и универсальные компоненты и библиотеки.

При этом ООП - не панацея, и не всегда это удобно и необходимо.

Ссылки

Теория ООП и использование в PHP — htmlacademy.github.io/intensive-php-guide/content-07.html

Функциональное программирование vs ООП —  elisdn.ru/blog/95/functional-vs-oop

Где взять курс — elisdn.ru/oop-week

<hr>

<h1>Классы и объекты<h1>

Неделя ООП. День 2. От философии к написанию классов и созданию объектов.

Темы поста: структура класса, создание объекта, абстракция, энтерпрайз-паттерн "Репозиторий", паттерн "Фабрика", объект как "Хранилище данных", объект как "Сервис" и полоноценный объект в PHP.

Главная идея данного урока заключается в том, что написание классов само по себе к ООП не имеет никакого отношения. 

ООП - это особое мышление программиста. Умение абстрагировать свои классы и разделить ответственность между ними. 

Автор курса советует выносить функционал в  специальные классы — сервисы, а работу с данными из разных источников (txt, xml, json, db) предоставить репозиториям. 

В широком смысле, класс —  это просто абстрактный тип данных.

Чем отличаются абстракция и реализация?

Абстракция описывает что-то простыми человеческими терминами в декларативном стиле на определенном уровне (уровень абстракции). Компьютер - несколько ящиков, соединенных провадами.

Реализация описывает что-то подробно множественными техническими терминами и нюансами в императивном стиле. Компьютер - набор из 80 миллионов транзисторов, способные пропускать и не пропускать ток.

Комментарий в коде — абстракция.
Прокомментированный код — реализация. 

Чтобы код стал абстрактным, его нужно поместить в функцию и дать ей человеко-понятное смысловое имя. Тогда от комментария можно избавиться.

Подробнее про классы и объекты здесь — youtube.com/playlist?list=PL6LDsbZOeyrx462VmH18qS0a9Dw9LwpSu

Структура класса

Листинг —  telegra.ph/Struktura-klassa-03-04

Создание объекта

$a = new className();
- создаст экземпляр класса (объект) и присвоит его переменной $a. 

Паттерн "Репозиторий"

Репозиторий является посредником между слоем доступа к данным и доменным слоем,
работая как in-memory коллекция доменных обектов. Клиенты создают декларативные
описания запросов и передают их в репозиторий для выполнения. — свободный перевод Мартина Фаулера

Паттерн "Фабрика"

Порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса.

Листинг — telegra.ph/Shema-patternov-Repozitorij-i-Fabrika-03-04

Типизация

Строгая типизация лучше нестрогой.

Всё ли можно запихнуть в класс?

Нет, лучше логически разделить большой класс на несколько маленьких, сгруппировав по смыслу.

Всё ли порождённое из класса является объектом?

Нет, иногда классы используются просто для хранения полей, представляя собой пользовательский тип данных.

class Address
{
    public $country;
    public $region;
    public $city;
    public $street;
    public $house;
}

Виды объектов и их отличия от «необъектов»

Хранилище данных — только список полей.

Сервис — только список методов.

Полноценный объект — методы и поля изменяющие состояние.

Ссылки:

Классы и объекты в PHP — php.net/manual/ru/language.oop5.php

Паттерн «Репозиторий». Основы и разъяснения — habrahabr.ru/post/248505/

«Фабричный метод» —refactoring.guru/ru/design-patterns/factory-method

Семантическое программирование: куда поместить код (доклад) — yiiconf.ru/ru/offers/offer/248

Куда поместить код: статический метод или сервис — elisdn.ru/blog/94/static-method-vs-service

Где взять курс — elisdn.ru/oop-week

<hr>

<h1>Полиморфизм. Наследование. Инкапсуляция.<h1>

Неделя ООП. День 3. Как писать классы удобными.

Инкапсуляция

Зачем вообще нужны приватные поля, статические и магические методы?

На первый взгляд, это только всё усложняет. И при неосмысленном использовании "статики" и "магиии" так и будет. 

Если программист просто так сделает поля private, напишет к ним сеттеры и геттеры, напишет ненужный конструктор, то структура приложения станет еще более запутанной. 

Но, если он туда поместит генерирование событий, различные проверки, валидацию, инициализацию в конструкторе и так далее, то структура приложения станет более понятной и удобной, так как не придется писать множественные дополнительные проверки через if'ы в контроллере. 

Кстати, сеттеры в любом случае считаются антипаттерном. Использовать их не рекомендуется.

Статика — php.net/manual/ru/language.oop5.static.php

Магия — php.net/manual/ru/language.oop5.magic.php

Область видимости (public/private)— php.net/manual/ru/language.oop5.visibility.php

Наследование

Наследование позволяет создавать производные классы (классы наследники), взяв за основу все методы и свойства базового класса (класса родителя), что очень полезно для расширения класса или для переопределения его свойств и методов в наследнике, оставляя родительский класс чистым. Синтаксис — php.net/manual/ru/language.oop5.inheritance.php 

Правила наследования

Наследоваться можно только от одного родителя. 

Не стоит строить длинные цепочки наследования. 

Дополнить метод родительского класса методом дочернего класса можно с помощью ключевого слова parrent::
 
Private методы не наследуются. Вместо них используются protected.

Возможность унаследованным методам иметь доступ к статическим константам, методам и свойствам класса потомка, а не только родительского класса, предоставляет позднее статическое связывание с помощью ключевого слова  static:: — habrahabr.ru/post/23066/

Рекомендуемый порядок объявления методов

1. public
2. protected
3. private

Красиво добавлять объектам новую функциональность позволяет паттерн "Декоратор" — refactoring.guru/ru/design-patterns/decorator

Наследование или реализацию можно запрещать

abstract class - класс, экземпляр которого, нельзя создать 

final class - класс, от которого нельзя наследоваться

В абстрактном классе можно создавать абстрактные методы: abstract protected function test (); Эти методы обязательно нужно будет переопределить в наследнике.

Отличия абстрактного класса от интерфейса

Абстрактный класс — это класс, у которого не реализован один или больше методов.

Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Реализаций интерфейса в классе, в отличии от наследования, может быть множество.

Интерфейсы используются в определениях чтобы указать, что объект, который будет использован на самом деле, должен реализовывать набор методов.

class Template implements iTemplate,  bTemplate, cTemplate { }

Паттерн "Делегирование" (Delegation)

Вместо наследования, можно сделать так, чтобы объект, вместо того чтобы выполнять одну из своих поставленных задач, поручал её связанному вспомогательному объекту. Такой шаблон называется "Делегирование" —  designpatternsphp.readthedocs.io/ru/latest/More/Delegation/README.html

Trait

Иногда хочется использовать множественное наследование. Обычно это признак неправильной архитектуры. Но, если очень нужно, в php можно использовать trait. Пару слов про трейты —  rmcreative.ru/blog/post/zlo-li-treyty

Полиморфизм: «один интерфейс, множество реализаций»

Теория  —  habrahabr.ru/post/37610/

Ссылки

Подробно об объектах и классах в PHP — habrahabr.ru/company/mailru/blog/255237/

Чем отличаются static, self и parent в php — ru.stackoverflow.com/questions/494807/Чем-отличаются-static-self-и-parent-в-php

Я не знаю, что такое ООП
 — habrahabr.ru/post/147927

Паттерн "Шаблонный метод" —  designpatternsphp.readthedocs.io/ru/latest/Behavioral/TemplateMethod/README.html

Где взять курс — elisdn.ru/oop-week.
